=Benchmarking Results=

=== smallpt.lua ===

|| Implementation || Time || Notes ||
|| std lua || 1217s || standard lua with vectors implemented in lua (see below for source code) ||
|| gcvec || 770s || standard lua + C vector module (garbage collected userdata) ||
|| lua-vec || 274s || lua with vectors (our implementation) ||
|| luajit || na || ||
|| luajit+lua-vec || na || ||

===Lua vector implementation ===

{{{
luavec = {}

function luavec.new(x, y, z, w)
  local v = { x or 0, y or 0, z or 0, w or 0 }
  setmetatable(v, mt)
  return v
end

function luavec.normalize(v)
  local s = 1.0 / math.sqrt(v[1]*v[1] + v[2]*v[2] + v[3]*v[3] + v[4]*v[4]);
  return luavec.new(v[1]*s, v[2]*s, v[3]*s, v[4]*s)
end

function luavec.dot(v1, v2)
  return v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3]
end

function luavec.cross(v1, v2)
  return luavec.new(v1[2] * v2[3] - v1[3] * v2[2], v1[3] * v2[1] - v1[1] * v2[3], v1[1] * v2[2] - v1[2] * v2[1])
end

mt = {}
mt.__add = function(v1, v2) return luavec.new(v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3], v1[4] + v2[4]) end
mt.__sub = function(v1, v2) return luavec.new(v1[1] - v2[1], v1[2] - v2[2], v1[3] - v2[3], v1[4] - v2[4]) end

mt.__mul = function(v1, v2)
  local s = tonumber(v2)
  if s then
    -- vector * scalar
    return luavec.new(v1[1] * s, v1[2] * s, v1[3] * s, v1[4] * s)
  else
    -- vector * vector
    return luavec.new(v1[1] * v2[1], v1[2] * v2[2], v1[3] * v2[3], v1[4] * v2[4])
  end
end

mt.__unm = function(v) return luavec.new(-v[1], -v[2], -v[3], -v[4]) end
}}}